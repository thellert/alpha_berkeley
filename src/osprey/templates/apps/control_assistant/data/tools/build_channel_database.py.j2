"""
Simple Channel Database Builder

Builds a templated channel database from simple CSV format.

**CSV Format:**
address,description,family_name,instances,sub_channel

- Rows with family_name: grouped into templates
- Rows without family_name: standalone channels
"""

import sys
import json
import csv
from pathlib import Path
from collections import defaultdict
from typing import List, Dict
from datetime import datetime

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from {{ package_name }}.services.channel_finder.utils.config import get_config, resolve_path


def load_csv(csv_path: Path) -> List[Dict]:
    """Load CSV, skipping comment lines."""
    channels = []
    with open(csv_path, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            address = row.get('address', '').strip()
            # Skip comments and empty rows
            if not address or address.startswith('#'):
                continue

            # Clean values
            cleaned = {k: v.strip() if v and v.strip() else None
                      for k, v in row.items()}
            channels.append(cleaned)

    return channels


def group_by_family(channels: List[Dict]) -> tuple:
    """Group channels by family_name."""
    families = defaultdict(list)
    standalone = []

    for ch in channels:
        family = ch.get('family_name')
        if family:
            families[family].append(ch)
        else:
            standalone.append(ch)

    return dict(families), standalone


def find_common_description(descriptions: List[str]) -> str:
    """
    Find the common part of all descriptions.
    Uses the longest common substring approach.
    """
    if not descriptions:
        return ""

    if len(descriptions) == 1:
        return descriptions[0]

    # Start with first description
    common = descriptions[0]

    # Find longest common substring with all others
    for desc in descriptions[1:]:
        # Find common parts (simple approach: find longest common prefix of words)
        common_words = []
        common_split = common.lower().split()
        desc_split = desc.lower().split()

        # Find common starting words
        for i, word in enumerate(common_split):
            if i < len(desc_split) and desc_split[i] == word:
                common_words.append(word)
            else:
                break

        if common_words:
            # Take the common part from the original (to preserve capitalization)
            common = ' '.join(common.split()[:len(common_words)])
        else:
            # No common prefix, return generic
            return ""

    # Clean up the result
    common = common.strip()

    # Remove trailing punctuation (dash, comma, etc.)
    common = common.rstrip(' -,;:')

    # If it's too short or doesn't make sense, return empty
    if len(common.split()) < 3:
        return ""

    return common


def create_template(family_name: str, channels: List[Dict]) -> Dict:
    """Create a template from a family group."""
    first = channels[0]

    # Get instance count
    instances = int(first.get('instances', 1))

    # Get sub-channels from all rows in this family
    sub_channels = []
    channel_descriptions = {}
    all_descriptions = []

    for ch in channels:
        sub_ch = ch.get('sub_channel')
        desc = ch.get('description', '')
        if sub_ch and sub_ch not in sub_channels:
            sub_channels.append(sub_ch)
            channel_descriptions[sub_ch] = desc
            all_descriptions.append(desc)

    # Find common description from all channel descriptions
    base_description = find_common_description(all_descriptions)
    if not base_description:
        # Fallback to generic description
        base_description = f"{family_name} device family"

    # Strip the common prefix from sub-channel descriptions to avoid redundancy
    # The base description will be shown as a header, so we only need unique parts
    if base_description and base_description != f"{family_name} device family":
        cleaned_channel_descriptions = {}
        for sub_ch, desc in channel_descriptions.items():
            # Remove the base description prefix (with separator like " - ")
            if desc.startswith(base_description):
                # Remove base description and any following separator
                unique_part = desc[len(base_description):].lstrip(' -:,;')
                # Capitalize first letter if needed
                if unique_part:
                    unique_part = unique_part[0].lower() + unique_part[1:]
                cleaned_channel_descriptions[sub_ch] = unique_part
            else:
                cleaned_channel_descriptions[sub_ch] = desc
        channel_descriptions = cleaned_channel_descriptions

    # Simple address pattern - no axis detection complexity
    pattern = f"{family_name}" + "{instance:02d}{suffix}"

    # Build template
    template = {
        'template': True,
        'base_name': family_name,
        'instances': [1, instances],
        'sub_channels': sub_channels,
        'description': base_description,
        'address_pattern': pattern,
        'channel_descriptions': channel_descriptions
    }

    return template


def build_database(csv_path: Path, output_path: Path, use_llm: bool = False, config_path: Path = None):
    """Build channel database from CSV."""
    print("=" * 80)
    print("Channel Database Builder")
    print("=" * 80)
    print(f"\nInput CSV: {csv_path}")

    # Load CSV
    channels = load_csv(csv_path)
    print(f"Loaded {len(channels)} channels (excluding comments)")

    # Group by family
    families, standalone = group_by_family(channels)
    print(f"\nFound:")
    print(f"  - {len(families)} device families")
    print(f"  - {len(standalone)} standalone channels")

    # Create templates
    templates = []
    for family_name, family_channels in families.items():
        try:
            template = create_template(family_name, family_channels)
            templates.append(template)
            print(f"  ‚úì {family_name}: {len(family_channels)} channels ‚Üí template")
        except Exception as e:
            print(f"  ‚úó {family_name}: ERROR - {e}")
            standalone.extend(family_channels)

    # Build database with metadata
    db = {
        '_metadata': {
            'generated_from': str(csv_path.relative_to(Path.cwd())) if csv_path.is_relative_to(Path.cwd()) else str(csv_path),
            'generation_date': datetime.now().strftime('%Y-%m-%d'),
            'generator': 'build_channel_database.py',
            'llm_naming': {
                'enabled': use_llm,
                'model': None,
                'purpose': None
            },
            'description': 'Template-based channel database with automatic common description extraction'
        },
        'channels': []
    }

    # Add standalone channels with optional LLM naming
    if standalone:
        if use_llm:
            print(f"\nü§ñ Generating descriptive names for {len(standalone)} standalone channels using LLM...")
            try:
                # Import from same directory
                current_dir = Path(__file__).parent
                sys.path.insert(0, str(current_dir))
                from llm_channel_namer import create_namer_from_config

                namer = create_namer_from_config(config_path)
                print(f"  Using: {namer.model_id}")
                print(f"  Batch size: {namer.batch_size}")

                # Update metadata with LLM info
                db['_metadata']['llm_naming']['model'] = namer.model_id
                db['_metadata']['llm_naming']['purpose'] = f'Generated descriptive PascalCase names for {len(standalone)} standalone channels'

                # Prepare channels for naming
                channels_to_name = [
                    {
                        'short_name': ch.get('address', ''),
                        'description': ch.get('description', '')
                    }
                    for ch in standalone
                ]

        # Generate names
                generated_names = namer.generate_names(channels_to_name)
                print(f"  ‚úì Generated {len(generated_names)} names")

            except Exception as e:
                print(f"  ‚ö†Ô∏è  LLM naming failed: {e}")
                print(f"  Using addresses as channel names")
                generated_names = [ch.get('address', '') for ch in standalone]
        else:
            print(f"\nüìù Using addresses as channel names for standalone channels")
            generated_names = [ch.get('address', '') for ch in standalone]

        # Add standalone channels
    for i, ch in enumerate(standalone):
        db['channels'].append({
            'template': False,
                'channel': generated_names[i] if i < len(generated_names) else ch.get('address', ''),
                'address': ch.get('address', ''),
                'description': ch.get('description', '')
        })

    # Add templates
    db['channels'].extend(templates)

    # Update metadata with final stats
    db['_metadata']['stats'] = {
        'template_entries': len(templates),
        'standalone_entries': len(standalone),
        'total_entries': len(db['channels'])
    }

    # Add command to metadata
    cmd_parts = ['python', 'tools/build_channel_database.py']
    if use_llm:
        cmd_parts.append('--use-llm')
    if config_path:
        cmd_parts.extend(['--config', str(config_path)])
    db['_metadata']['command'] = ' '.join(cmd_parts)

    # Write output
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, 'w') as f:
        json.dump(db, f, indent=2)

    print(f"\n‚úÖ Database created successfully!")
    print(f"  üìã Templates: {len(templates)}")
    print(f"  üìÑ Standalone: {len(standalone)}")
    print(f"  üìä Total entries: {len(db['channels'])}")
    print(f"  üíæ Output: {output_path}")
    print("=" * 80)


def main():
    """Main entry point for the channel database builder."""
    import argparse

    parser = argparse.ArgumentParser(
        description='Build channel database from CSV file',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic usage (from facility directory)
  python tools/build_channel_database.py

  # With custom paths
  python tools/build_channel_database.py --csv data/raw/address_list.csv --output data/processed/my_database.json

  # With LLM naming for standalone channels
  python tools/build_channel_database.py --use-llm

  # Specify config file
  python tools/build_channel_database.py --config my_facility_config.yml

CSV Format:
  address,description,family_name,instances,sub_channel

  - Rows WITH family_name: grouped into templates
  - Rows WITHOUT family_name: standalone channels
  - Lines starting with # are treated as comments
        """
    )

    parser.add_argument(
        '--csv',
        type=Path,
        default=Path('data/raw/address_list.csv'),
        help='Input CSV file (default: data/raw/address_list.csv)'
    )

    parser.add_argument(
        '--output',
        type=Path,
        default=Path('data/processed/channel_database.json'),
        help='Output JSON file (default: data/processed/channel_database.json)'
    )

    parser.add_argument(
        '--use-llm',
        action='store_true',
        help='Use LLM to generate descriptive names for standalone channels (requires API access)'
    )

    parser.add_argument(
        '--config',
        type=Path,
        help='Path to facility config file (optional, auto-detected if not provided)'
    )

    args = parser.parse_args()

    # Validate inputs
    if not args.csv.exists():
        print(f"‚ùå Error: CSV file not found: {args.csv}")
        print(f"   Current directory: {Path.cwd()}")
        sys.exit(1)

    # Build database
    try:
        build_database(
            csv_path=args.csv,
        output_path=args.output,
            use_llm=args.use_llm,
        config_path=args.config
    )
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()

