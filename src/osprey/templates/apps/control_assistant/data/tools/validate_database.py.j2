"""
Database Validation Tool

Validates channel database JSON files for correctness and compatibility with the system.
Useful for users who manually create or edit database JSON files (Workflow B).
Auto-detects pipeline type (hierarchical vs in_context) and validates accordingly.

Usage:
    python tools/validate_database.py
    python tools/validate_database.py --database path/to/database.json
    python tools/validate_database.py --verbose
"""

import sys
import json
from pathlib import Path
from typing import List, Dict, Tuple

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from {{ package_name }}.services.channel_finder.utils.config import get_config, resolve_path
from {{ package_name }}.services.channel_finder.databases import TemplateChannelDatabase, HierarchicalChannelDatabase

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich import box

try:
    from osprey.cli.styles import console as osprey_console, get_active_theme, Messages
    console = osprey_console
    theme = get_active_theme()
except ImportError:
    # Fallback if osprey styles not available
    console = Console()
    theme = None
    Messages = None


def detect_pipeline_config(config):
    """Detect which pipeline is configured.

    Returns:
        tuple: (pipeline_type, db_config) where pipeline_type is 'hierarchical' or 'in_context'
    """
    cf_config = config.get('channel_finder', {})
    pipelines = cf_config.get('pipelines', {})

    # Check for explicit pipeline_mode setting
    pipeline_mode = cf_config.get('pipeline_mode')

    # Get pipeline configurations
    hierarchical_config = pipelines.get('hierarchical', {})
    in_context_config = pipelines.get('in_context', {})

    # If pipeline_mode is explicitly set, use that
    if pipeline_mode == 'in_context' and in_context_config.get('database', {}).get('path'):
        return 'in_context', in_context_config.get('database', {})
    elif pipeline_mode == 'hierarchical' and hierarchical_config.get('database', {}).get('path'):
        return 'hierarchical', hierarchical_config.get('database', {})

    # Otherwise, fall back to checking which database exists (prefer hierarchical)
    if hierarchical_config.get('database', {}).get('path'):
        return 'hierarchical', hierarchical_config.get('database', {})
    elif in_context_config.get('database', {}).get('path'):
        return 'in_context', in_context_config.get('database', {})
    else:
        return None, None


def validate_json_structure(db_path: Path) -> Tuple[bool, List[str], List[str]]:
    """
    Validate JSON file structure and schema.

    Returns:
        (is_valid, errors, warnings)
    """
    errors = []
    warnings = []

    # Check file exists
    if not db_path.exists():
        errors.append(f"Database file not found: {db_path}")
        return False, errors, warnings

    # Check file is readable JSON
    try:
        with open(db_path, 'r') as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        errors.append(f"Invalid JSON format: {e}")
        return False, errors, warnings
    except Exception as e:
        errors.append(f"Error reading file: {e}")
        return False, errors, warnings

    # Check top-level structure
    if isinstance(data, list):
        # Legacy format: just an array of channels
        warnings.append("Using legacy array format. Consider using dict format with metadata.")
        channels = data
    elif isinstance(data, dict):
        # Modern format: dict with metadata
        if 'channels' not in data:
            errors.append("Missing 'channels' key in database dict")
            return False, errors, warnings
        channels = data['channels']

        # Check presentation mode (informational only)
        if 'presentation_mode' in data:
            valid_modes = ['explicit', 'template']
            if data['presentation_mode'] not in valid_modes:
                warnings.append(f"Unknown presentation_mode: {data['presentation_mode']}. Valid: {valid_modes}")
    else:
        errors.append(f"Invalid top-level type: {type(data)}. Expected list or dict.")
        return False, errors, warnings

    # Validate channels array
    if not isinstance(channels, list):
        errors.append(f"'channels' must be a list, got {type(channels)}")
        return False, errors, warnings

    if len(channels) == 0:
        errors.append("Database contains no channels")
        return False, errors, warnings

    # Validate each channel entry
    for i, entry in enumerate(channels):
        if not isinstance(entry, dict):
            errors.append(f"Channel {i}: must be a dict, got {type(entry)}")
            continue

        # Check for template field
        is_template = entry.get('template', False)

        if is_template:
            # Validate template entry
            required = ['base_name', 'instances', 'description']
            for field in required:
                if field not in entry:
                    errors.append(f"Template {i}: missing required field '{field}'")

            # Check instances format
            if 'instances' in entry:
                instances = entry['instances']
                if not isinstance(instances, list) or len(instances) != 2:
                    errors.append(f"Template {i}: 'instances' must be [start, end], got {instances}")
                elif instances[0] > instances[1]:
                    errors.append(f"Template {i}: instance start ({instances[0]}) > end ({instances[1]})")

            # Check sub_channels if present
            if 'sub_channels' in entry:
                if not isinstance(entry['sub_channels'], list):
                    errors.append(f"Template {i}: 'sub_channels' must be a list")
                elif len(entry['sub_channels']) == 0:
                    warnings.append(f"Template {i}: 'sub_channels' is empty")

            # Check axes if present
            if 'axes' in entry:
                if not isinstance(entry['axes'], list):
                    errors.append(f"Template {i}: 'axes' must be a list")

            # Check address_pattern
            if 'address_pattern' not in entry:
                warnings.append(f"Template {i}: missing 'address_pattern'. Will use default pattern.")

            # Check channel_descriptions
            if 'channel_descriptions' not in entry:
                warnings.append(f"Template {i}: missing 'channel_descriptions'. Will use generic descriptions.")
        else:
            # Validate standalone entry
            required = ['channel', 'address', 'description']
            for field in required:
                if field not in entry:
                    errors.append(f"Channel {i}: missing required field '{field}'")

            # Check for empty values
            for field in ['channel', 'address', 'description']:
                if field in entry and not entry[field]:
                    warnings.append(f"Channel {i}: field '{field}' is empty")

    is_valid = len(errors) == 0
    return is_valid, errors, warnings


def validate_database_loading(db_path: Path, pipeline_type: str) -> Tuple[bool, List[str], Dict]:
    """
    Test loading database through the actual database class.

    Args:
        db_path: Path to database file
        pipeline_type: Either 'hierarchical' or 'in_context'

    Returns:
        (success, errors, stats)
    """
    errors = []
    stats = {}

    try:
        # Try to load database based on pipeline type
        if pipeline_type == 'hierarchical':
            db = HierarchicalChannelDatabase(str(db_path))
        else:  # in_context
            db = TemplateChannelDatabase(str(db_path), presentation_mode='explicit')

        # Get statistics
        stats = db.get_statistics()

        # Test basic operations
        all_channels = db.get_all_channels()
        if not all_channels:
            errors.append("Database loaded but get_all_channels() returned empty list")

        # Test channel lookup
        if all_channels:
            first_channel = all_channels[0]['channel']
            lookup_result = db.get_channel(first_channel)
            if not lookup_result:
                errors.append(f"Channel lookup failed for: {first_channel}")

        return True, errors, stats

    except Exception as e:
        errors.append(f"Failed to load database: {e}")
        import traceback
        errors.append(traceback.format_exc())
        return False, errors, {}


def print_validation_results(is_valid: bool, errors: List[str], warnings: List[str],
                             stats: Dict = None, verbose: bool = False, pipeline_type: str = None):
    """Print formatted validation results using rich console and osprey theme."""
    console.print()

    # Header
    if is_valid and not errors:
        header_text = "[bold success]‚úÖ VALID[/bold success]\n[dim]Database passed all checks[/dim]"
        border_style = "success"
    else:
        header_text = "[bold error]‚ùå INVALID[/bold error]\n[dim]Database has errors[/dim]"
        border_style = "error"

    console.print(
        Panel.fit(
            header_text,
            border_style=border_style,
            padding=(1, 2)
        )
    )

    # Errors
    if errors:
        console.print()
        error_table = Table(show_header=False, box=box.SIMPLE, padding=(0, 1))
        error_table.add_column("", style="error", no_wrap=False)

        for error in errors:
            error_table.add_row(f"‚Ä¢ {error}")

        console.print(
            Panel(
                error_table,
                title=f"[bold error]üî¥ ERRORS ({len(errors)})[/bold error]",
                border_style="error",
                padding=(1, 2)
            )
        )

    # Warnings
    if warnings:
        console.print()
        warning_table = Table(show_header=False, box=box.SIMPLE, padding=(0, 1))
        warning_table.add_column("", style="warning", no_wrap=False)

        for warning in warnings:
            warning_table.add_row(f"‚Ä¢ {warning}")

        console.print(
            Panel(
                warning_table,
                title=f"[bold warning]‚ö†Ô∏è  WARNINGS ({len(warnings)})[/bold warning]",
                border_style="warning",
                padding=(1, 2)
            )
        )

    # Statistics
    if stats:
        console.print()
        stats_table = Table(show_header=False, box=box.SIMPLE, padding=(0, 2))
        stats_table.add_column("Metric", style="label", no_wrap=True)
        stats_table.add_column("Value", style="value")

        if pipeline_type:
            stats_table.add_row("Pipeline Type", pipeline_type.replace('_', ' ').title())

        stats_table.add_row("Format", stats.get('format', 'unknown'))
        stats_table.add_row("Total Channels", str(stats.get('total_channels', 0)))

        if 'template_entries' in stats:
            stats_table.add_row("Template Entries", str(stats['template_entries']))
        if 'standalone_entries' in stats:
            stats_table.add_row("Standalone Entries", str(stats['standalone_entries']))
        if 'compressed_ratio' in stats:
            stats_table.add_row("Compression Ratio", f"{stats['compressed_ratio']:.1f}x")
        if 'systems' in stats:
            system_count = len(stats['systems'])
            stats_table.add_row("Systems", str(system_count))

        console.print(
            Panel(
                stats_table,
                title="[bold]üìä DATABASE STATISTICS[/bold]",
                border_style="info",
                padding=(1, 2)
            )
        )

        # Verbose detailed stats
        if verbose:
            console.print()
            detailed_table = Table(show_header=False, box=box.SIMPLE, padding=(0, 2))
            detailed_table.add_column("Key", style="dim", no_wrap=True)
            detailed_table.add_column("Value", style="dim")

            for key, value in sorted(stats.items()):
                if key not in ['format', 'total_channels', 'template_entries',
                              'standalone_entries', 'compressed_ratio', 'systems']:
                    detailed_table.add_row(key, str(value))

            if detailed_table.row_count > 0:
                console.print(
                    Panel(
                        detailed_table,
                        title="[bold]üîç DETAILED STATISTICS[/bold]",
                        border_style="dim",
                        padding=(1, 2)
                    )
                )

    # Success message
    if not errors and not warnings:
        console.print()
        console.print("[success]‚ú® No issues found![/success]")

    console.print()


def main():
    """Main validation routine."""
    import argparse

    parser = argparse.ArgumentParser(
        description='Validate channel database JSON files (auto-detects hierarchical vs in-context)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Validate configured database (auto-detect pipeline)
  python tools/validate_database.py

  # Validate specific file
  python tools/validate_database.py --database my_custom_db.json

  # Verbose output
  python tools/validate_database.py --verbose
        """
    )
    parser.add_argument(
        '--database', '-d',
        help='Path to database file (default: from config)'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show detailed statistics'
    )
    parser.add_argument(
        '--pipeline',
        choices=['hierarchical', 'in_context'],
        help='Override pipeline type detection (default: auto-detect from config)'
    )

    args = parser.parse_args()

    # Determine database path and pipeline type
    pipeline_type = args.pipeline

    if args.database:
        db_path = Path(args.database)
        # If database is specified but pipeline type isn't, try to detect from config
        if not pipeline_type:
            try:
                config = get_config()
                detected_type, _ = detect_pipeline_config(config)
                if detected_type:
                    pipeline_type = detected_type
                else:
                    # Default to in_context if can't detect
                    pipeline_type = 'in_context'
            except:
                pipeline_type = 'in_context'
    else:
        # Get from config
        try:
            config = get_config()
            detected_type, db_config = detect_pipeline_config(config)

            if not detected_type:
                console.print()
                console.print(
                    Panel(
                        "[bold error]Error:[/bold error] No database configured\n\n"
                        "[warning]Check config.yml:[/warning] Configure either:\n"
                        "  ‚Ä¢ channel_finder.pipelines.hierarchical.database.path\n"
                        "  ‚Ä¢ channel_finder.pipelines.in_context.database.path",
                        border_style="error",
                        title="‚ùå Configuration Error"
                    )
                )
                return 1

            pipeline_type = detected_type
            db_path_str = db_config.get('path')
            if not db_path_str:
                console.print()
                console.print(
                    Panel(
                        "[bold error]Error:[/bold error] No database path in config",
                        border_style="error",
                        title="‚ùå Configuration Error"
                    )
                )
                return 1
            db_path = resolve_path(db_path_str)
        except Exception as e:
            console.print()
            console.print(
                Panel(
                    f"[bold error]Error reading config:[/bold error] {e}",
                    border_style="error",
                    title="‚ùå Configuration Error"
                )
            )
            return 1

    # Header
    console.print()
    console.print(
        Panel.fit(
            "[bold primary]Database Validation Tool[/bold primary]\n"
            f"[dim]Pipeline: {pipeline_type.replace('_', ' ').title()}[/dim]",
            border_style="primary",
            padding=(1, 2)
        )
    )

    # Configuration info
    console.print()
    config_table = Table(show_header=False, box=box.SIMPLE, padding=(0, 2))
    config_table.add_column("Property", style="label")
    config_table.add_column("Value", style="value")
    config_table.add_row("Database Path", str(db_path))
    config_table.add_row("Pipeline Type", pipeline_type.replace('_', ' ').title())

    console.print(Panel(config_table, title="[bold]Configuration[/bold]", border_style="info"))

    # Step 1: Validate JSON structure (only for in_context databases)
    if pipeline_type == 'in_context':
        with console.status("[bold info]Checking JSON structure...", spinner="dots"):
            is_valid, errors, warnings = validate_json_structure(db_path)

        if not is_valid:
            print_validation_results(False, errors, warnings, verbose=args.verbose, pipeline_type=pipeline_type)
            return 1
    else:
        # For hierarchical databases, skip JSON validation and just try to load
        errors = []
        warnings = []
        is_valid = True

    # Step 2: Validate database loading
    with console.status("[bold info]Testing database loading...", spinner="dots"):
        load_success, load_errors, stats = validate_database_loading(db_path, pipeline_type)

    errors.extend(load_errors)
    is_valid = is_valid and load_success

    # Print results
    print_validation_results(is_valid, errors, warnings, stats, verbose=args.verbose, pipeline_type=pipeline_type)

    return 0 if is_valid else 1


if __name__ == '__main__':
    sys.exit(main())

