"""
Current Weather Capability for Hello World Weather Tutorial.

Implements weather data retrieval capability for the Alpha Berkeley Agent Framework,
demonstrating essential capability patterns including LangGraph integration, state
management, error handling, and orchestration guidance. This capability serves as
the primary business logic component for weather information retrieval in the
Hello World Weather tutorial application.

The capability integrates with the framework's execution system through the
@capability_node decorator, providing automatic error handling, retry policies,
streaming support, and state management integration. It demonstrates key patterns
for building production-ready capabilities within the framework ecosystem.

Architecture Integration:
    The capability integrates with multiple framework systems:
    
    1. **Execution System**: LangGraph node integration via @capability_node decorator
    2. **State Management**: Context storage and retrieval through StateManager utilities
    3. **Streaming System**: Real-time status updates during execution
    4. **Error Handling**: Classification and retry coordination for robust operation
    5. **Orchestration**: Planning guidance for intelligent step sequencing
    6. **Classification**: Task analysis guidance for capability selection

Business Logic:
    The capability implements a complete weather retrieval workflow:
    
    1. **Location Extraction**: Simple pattern matching from user queries
    2. **Weather Retrieval**: Mock API integration for weather data
    3. **Context Creation**: Structured data packaging in CurrentWeatherContext
    4. **State Storage**: Framework integration via StateManager utilities
    5. **Status Streaming**: Real-time progress updates for user feedback

.. note::
   This capability uses a mock weather service for tutorial purposes.
   Production implementations should integrate with real weather APIs
   like OpenWeatherMap, WeatherAPI, or similar services.

.. warning::
   Location detection uses simple string matching and supports only
   San Francisco, New York, and Prague. Production implementations
   should use more sophisticated location parsing and broader coverage.
"""

from typing import Dict, Any, Optional

from framework.base import (
    BaseCapability, capability_node,
    OrchestratorGuide, OrchestratorExample, PlannedStep,
    ClassifierActions, ClassifierExample, TaskClassifierGuide
)
from framework.base.errors import ErrorClassification, ErrorSeverity
from framework.registry import get_registry
from framework.state import AgentState, StateManager
from configs.logger import get_logger
from configs.streaming import get_streamer

from applications.hello_world_weather.context_classes import CurrentWeatherContext
from applications.hello_world_weather.mock_weather_api import weather_api

logger = get_logger("hello_world_weather", "current_weather")
registry = get_registry()

@capability_node
class CurrentWeatherCapability(BaseCapability):
    """Weather data retrieval capability for current conditions.
    
    Implements the complete workflow for retrieving current weather conditions
    including location extraction, weather service integration, context creation,
    and framework state management. This capability demonstrates essential patterns
    for building production-ready capabilities within the Alpha Berkeley Agent Framework.
    
    The capability follows the framework's convention-based architecture with automatic
    discovery, LangGraph integration, and comprehensive error handling. It serves as
    a reference implementation for developers learning capability development patterns
    and demonstrates integration with multiple framework systems.
    
    Capability Characteristics:
        - **Name**: "current_weather" (unique identifier for registry and routing)
        - **Description**: Human-readable description for documentation and logging
        - **Provides**: ["CURRENT_WEATHER"] - Context type generated by this capability
        - **Requires**: [] - No input context dependencies for standalone operation
        - **LangGraph Integration**: Full node integration via @capability_node decorator
    
    Execution Workflow:
        The capability implements a structured execution pattern:
        
        1. **Initialization**: Extract current step and initialize streaming support
        2. **Location Detection**: Parse user query for supported location names
        3. **Weather Retrieval**: Call mock weather service for current conditions
        4. **Context Creation**: Package weather data in CurrentWeatherContext
        5. **State Storage**: Store context using StateManager utilities
        6. **Status Updates**: Provide real-time progress feedback via streaming
    
    Error Handling:
        The capability implements domain-specific error classification:
        
        - **Retriable Errors**: Connection and timeout errors with retry coordination
        - **Critical Errors**: All other exceptions requiring immediate attention
        - **Retry Policy**: 3 attempts with exponential backoff (0.5s base, 1.5x factor)
    
    Orchestration Integration:
        Provides planning guidance for intelligent workflow orchestration:
        
        - **Usage Scenarios**: When to include weather retrieval in execution plans
        - **Output Context**: CURRENT_WEATHER context type for downstream capabilities
        - **Success Criteria**: Clear indicators of successful weather data retrieval
        - **Location Support**: Explicit documentation of supported cities
    
    Classification Integration:
        Guides task classification for capability selection:
        
        - **Positive Examples**: Queries requiring current weather information
        - **Negative Examples**: Historical weather, forecasts, or non-weather queries
        - **Classification Logic**: Clear reasoning for capability activation
    
    .. note::
       This capability is designed for tutorial purposes and uses simplified
       location detection. Production capabilities should implement more
       sophisticated natural language processing for location extraction.
    
    .. warning::
       The capability currently supports only three cities (San Francisco,
       New York, Prague) and defaults to San Francisco for unrecognized locations.
       Extend location support for production use cases.
    
    Examples:
        Capability usage in LangGraph execution::
        
            >>> # Capability is automatically registered and available for planning
            >>> # Framework handles execution through @capability_node decorator
            >>> state = AgentState({"task_current_task": "What's the weather in New York?"})
            >>> result = await CurrentWeatherCapability.langgraph_node(state)
            >>> print(result.get("context_CURRENT_WEATHER"))
        
        Manual capability testing::
        
            >>> state = create_test_state("How's the weather in Prague?")
            >>> updates = await CurrentWeatherCapability.execute(state)
            >>> weather_context = updates["context_CURRENT_WEATHER"]["prague_weather"]
            >>> print(f"{weather_context.location}: {weather_context.temperature}°C")
            Prague: 15.0°C
    
    .. seealso::
       :class:`framework.base.BaseCapability` : Base class with required method implementations
       :func:`framework.base.capability_node` : Decorator providing LangGraph integration
       :class:`CurrentWeatherContext` : Context class for weather data storage
       :class:`SimpleWeatherAPI` : Mock weather service used by this capability
       :class:`framework.state.StateManager` : State management utilities
    """
    
    # Required class attributes for registry configuration
    name = "current_weather"
    description = "Get current weather conditions for a location"
    provides = ["CURRENT_WEATHER"]
    requires = []
    
    @staticmethod
    async def execute(state: AgentState, **kwargs) -> Dict[str, Any]:
        """Execute complete weather data retrieval workflow.
        
        Implements the core business logic for weather data retrieval including
        location extraction from user queries, weather service integration, context
        creation, and framework state management. This method demonstrates essential
        patterns for capability implementation within the Alpha Berkeley Agent Framework.
        
        The execution workflow follows a structured pattern that integrates with
        multiple framework systems while maintaining clear separation of concerns
        between business logic, state management, and user feedback systems.
        
        Execution Steps:
            1. **State Extraction**: Retrieve current execution step and task information
            2. **Streaming Setup**: Initialize real-time status updates for user feedback
            3. **Location Detection**: Parse user query for supported location names
            4. **Weather Retrieval**: Call weather service API for current conditions
            5. **Context Creation**: Package weather data in structured context object
            6. **State Integration**: Store context using framework state management
            7. **Status Updates**: Provide completion feedback via streaming system
        
        Location Detection Logic:
            Uses simple string matching to identify supported cities:
            
            - **New York**: Matches "new york" or "nyc" in lowercase query
            - **Prague**: Matches "prague" or "praha" in lowercase query
            - **San Francisco**: Default fallback for all other queries
        
        State Management Integration:
            The method uses StateManager utilities for proper framework integration:
            
            - **Context Storage**: Stores weather data using registry context types
            - **Key Management**: Uses step context key for unique identification
            - **State Updates**: Returns LangGraph-compatible state update dictionary
        
        :param state: Current agent state containing execution context and task information
        :type state: AgentState
        :param kwargs: Additional execution parameters (unused in current implementation)
        :type kwargs: Any
        :return: LangGraph-compatible state update dictionary containing stored context data
        :rtype: Dict[str, Any]
        :raises Exception: Re-raises all exceptions for framework error handling coordination
        
        .. note::
           This method is called automatically by the @capability_node decorator
           which provides comprehensive error handling, retry coordination, and
           execution tracking around the business logic.
        
        .. warning::
           Location detection is simplified for tutorial purposes. Production
           implementations should use more sophisticated natural language processing
           for accurate location extraction from varied user input patterns.
        
        Examples:
            Typical execution flow::
            
                >>> state = AgentState({
                ...     "task_current_task": "What's the weather like in New York?",
                ...     "execution_plan": [...],
                ...     "current_step_index": 0
                ... })
                >>> updates = await CurrentWeatherCapability.execute(state)
                >>> weather_data = updates["context_CURRENT_WEATHER"]
                >>> print(f"Retrieved weather for: {list(weather_data.keys())}")
                Retrieved weather for: ['step_0']
            
            State integration pattern::
            
                >>> # Framework automatically merges returned updates into state
                >>> updated_state = {**state, **updates}
                >>> context_manager = ContextManager(updated_state)
                >>> weather_context = context_manager.get_context("CURRENT_WEATHER", "step_0")
        
        .. seealso::
           :class:`framework.state.StateManager` : State management utilities used by this method
           :class:`CurrentWeatherContext` : Context class created during execution
           :func:`get_streamer` : Streaming utilities for real-time status updates
           :class:`SimpleWeatherAPI` : Weather service integration
        """
        step = StateManager.get_current_step(state)
        streamer = get_streamer("hello_world_weather", "current_weather", state)
        
        try:
            streamer.status("Extracting location from query...")
            
            query = StateManager.get_current_task(state).lower()
            
            # Simple location detection
            location = "San Francisco"  # default
            if "new york" in query or "nyc" in query:
                location = "New York"
            elif "prague" in query or "praha" in query:
                location = "Prague"
            
            streamer.status(f"Getting weather for {location}...")
            weather = weather_api.get_current_weather(location)
            
            # Create context object
            context = CurrentWeatherContext(
                location=weather.location,
                temperature=weather.temperature,
                conditions=weather.conditions,
                timestamp=weather.timestamp
            )
            
            # Store context in framework state
            context_updates = StateManager.store_context(
                state, 
                registry.context_types.CURRENT_WEATHER, 
                step.get("context_key"), 
                context
            )
            
            streamer.status(f"Weather retrieved: {location} - {weather.temperature}°C")
            return context_updates
            
        except Exception as e:
            logger.error(f"Weather retrieval error: {e}")
            raise
    
    @staticmethod
    def classify_error(exc: Exception, context: dict) -> ErrorClassification:
        """Classify weather service errors for intelligent retry coordination.
        
        Analyzes exceptions from weather data retrieval operations and provides
        domain-specific error classification to guide the framework's retry and
        error handling systems. This method implements weather service specific
        error analysis patterns for robust operation in production environments.
        
        The classification system distinguishes between temporary service issues
        that benefit from retry attempts and permanent errors that require immediate
        attention or alternative handling strategies.
        
        Error Classification Logic:
            - **Retriable Errors**: Network connectivity and timeout issues that
              typically resolve with retry attempts (ConnectionError, TimeoutError)
            - **Critical Errors**: All other exceptions including data parsing errors,
              authentication failures, and programming errors that require immediate attention
        
        Retry Coordination:
            Classifications integrate with the framework's manual retry system:
            
            - **RETRIABLE**: Errors are routed through retry coordination with backoff
            - **CRITICAL**: Errors bypass retry system and bubble up for immediate handling
            - **User Messages**: Provide clear, actionable feedback for different error types
            - **Technical Details**: Include exception information for debugging and logging
        
        :param exc: Exception raised during weather data retrieval operations
        :type exc: Exception
        :param context: Execution context dictionary containing state and configuration
            information (unused in current implementation but available for enhanced
            error analysis)
        :type context: dict
        :return: Error classification with severity level, user message, and technical details
        :rtype: ErrorClassification
        
        .. note::
           This method is called automatically by the @capability_node decorator
           when exceptions occur during execute() method execution. The classification
           guides retry decisions and error reporting throughout the framework.
        
        .. warning::
           Error classification should be conservative - when in doubt, classify
           as CRITICAL to avoid infinite retry loops on permanent failures.
           Only classify errors as RETRIABLE when confident they represent
           temporary conditions.
        
        Examples:
            Network error classification::
            
                >>> exc = ConnectionError("Failed to connect to weather service")
                >>> classification = CurrentWeatherCapability.classify_error(exc, {})
                >>> print(classification.severity)
                ErrorSeverity.RETRIABLE
                >>> print(classification.user_message)
                Weather service timeout, retrying...
            
            Programming error classification::
            
                >>> exc = ValueError("Invalid temperature format")
                >>> classification = CurrentWeatherCapability.classify_error(exc, {})
                >>> print(classification.severity)
                ErrorSeverity.CRITICAL
                >>> print(classification.user_message)
                Weather service error: Invalid temperature format
            
            Integration with retry system::
            
                >>> # Framework uses classification to determine retry behavior
                >>> if classification.severity == ErrorSeverity.RETRIABLE:
                ...     # Route through retry coordination with backoff
                ...     retry_manager.schedule_retry(capability, context)
                ... else:
                ...     # Bubble up for immediate error handling
                ...     raise exc
        
        .. seealso::
           :class:`framework.base.ErrorClassification` : Error classification structure
           :class:`framework.base.ErrorSeverity` : Severity level enumeration
           :meth:`get_retry_policy` : Retry configuration for retriable errors
        """
        if isinstance(exc, (ConnectionError, TimeoutError)):
            return ErrorClassification(
                severity=ErrorSeverity.RETRIABLE,
                user_message="Weather service timeout, retrying...",
                technical_details=str(exc)
            )
        
        return ErrorClassification(
            severity=ErrorSeverity.CRITICAL,
            user_message=f"Weather service error: {str(exc)}",
            technical_details=f"Error: {type(exc).__name__}"
        )
    
    @staticmethod
    def get_retry_policy() -> Dict[str, Any]:
        """Define retry policy configuration for weather service operations.
        
        Provides retry coordination parameters for handling temporary weather service
        failures including network connectivity issues, service timeouts, and other
        transient errors. The policy balances quick recovery with service protection
        by implementing exponential backoff with reasonable limits.
        
        The retry policy integrates with the framework's manual retry system to provide
        consistent error recovery behavior across all capabilities while allowing
        domain-specific tuning for optimal performance characteristics.
        
        Policy Configuration:
            - **Max Attempts**: 3 total attempts (1 initial + 2 retries) to balance
              recovery success with reasonable response times
            - **Base Delay**: 0.5 seconds initial delay for quick recovery of brief outages
            - **Backoff Factor**: 1.5x exponential backoff to reduce service load during
              extended outages while maintaining reasonable total retry time
        
        Retry Timing:
            With the configured policy, retry attempts occur at:
            
            - **Attempt 1**: Immediate (initial execution)
            - **Attempt 2**: 0.5 seconds after first failure
            - **Attempt 3**: 0.75 seconds after second failure (0.5 * 1.5)
            - **Total Time**: ~1.25 seconds maximum retry duration
        
        :return: Dictionary containing retry policy configuration with keys:
            - max_attempts: Maximum number of execution attempts including initial
            - delay_seconds: Base delay in seconds before first retry attempt
            - backoff_factor: Multiplier for exponential backoff between retries
        :rtype: Dict[str, Any]
        
        .. note::
           This policy is specifically tuned for weather service characteristics
           where brief outages are common but extended failures typically indicate
           service maintenance or configuration issues requiring manual intervention.
        
        .. warning::
           Retry policies should be conservative to avoid overwhelming external
           services during outages. Consider service rate limits and fair usage
           policies when configuring retry parameters.
        
        Examples:
            Policy configuration access::
            
                >>> policy = CurrentWeatherCapability.get_retry_policy()
                >>> print(f"Max attempts: {policy['max_attempts']}")
                Max attempts: 3
                >>> print(f"Base delay: {policy['delay_seconds']}s")
                Base delay: 0.5s
            
            Integration with retry system::
            
                >>> # Framework uses policy for retry coordination
                >>> if error_classification.severity == ErrorSeverity.RETRIABLE:
                ...     policy = capability.get_retry_policy()
                ...     retry_manager.schedule_retry(
                ...         capability, context, policy
                ...     )
            
            Custom policy for different environments::
            
                >>> class ProductionWeatherCapability(CurrentWeatherCapability):
                ...     @staticmethod
                ...     def get_retry_policy() -> Dict[str, Any]:
                ...         return {
                ...             "max_attempts": 5,  # More aggressive retry
                ...             "delay_seconds": 1.0,  # Longer initial delay
                ...             "backoff_factor": 2.0  # Faster exponential backoff
                ...         }
        
        .. seealso::
           :meth:`classify_error` : Error classification that triggers retry policy usage
           :class:`framework.base.ErrorSeverity` : Severity levels that determine retry eligibility
           :doc:`/developer-guides/error-handling` : Complete error handling and retry guide
        """
        return {
            "max_attempts": 3,
            "delay_seconds": 0.5,
            "backoff_factor": 1.5
        }
    
    def _create_orchestrator_guide(self) -> Optional[OrchestratorGuide]:
        """Provide orchestration guidance for intelligent weather capability planning.
        
        Creates comprehensive guidance for the framework's orchestration system to
        understand when and how to include weather data retrieval in execution plans.
        This guidance enables intelligent workflow planning that optimizes capability
        sequencing, dependency management, and resource utilization.
        
        The guide includes detailed instructions, practical examples, and success
        criteria that help the orchestration system make informed decisions about
        weather capability integration in complex multi-step workflows.
        
        Guidance Components:
            - **Usage Instructions**: Clear criteria for when to plan weather retrieval steps
            - **Output Documentation**: Detailed description of generated context types
            - **Location Support**: Explicit documentation of supported cities and fallback behavior
            - **Example Scenarios**: Realistic planning examples with expected outcomes
            - **Success Criteria**: Measurable indicators of successful weather data retrieval
        
        Planning Integration:
            The orchestrator uses this guidance to:
            
            1. **Step Planning**: Determine when weather retrieval fits in execution workflows
            2. **Dependency Analysis**: Understand context types provided for downstream capabilities
            3. **Resource Planning**: Estimate execution time and external service dependencies
            4. **Error Handling**: Plan for weather service failures and fallback strategies
            5. **User Experience**: Optimize step sequencing for responsive user interactions
        
        :return: Complete orchestrator guidance containing instructions, examples,
            and metadata for intelligent planning, or None if guidance is not needed
        :rtype: Optional[OrchestratorGuide]
        
        .. note::
           The guidance is used during execution planning phase and does not affect
           runtime execution behavior. It serves as metadata for the planning system
           to make informed decisions about capability integration.
        
        .. warning::
           Guidance should accurately reflect capability behavior and limitations.
           Incorrect guidance can lead to poor planning decisions and execution failures.
        
        Examples:
            Orchestrator planning integration::
            
                >>> capability = CurrentWeatherCapability()
                >>> guide = capability._create_orchestrator_guide()
                >>> print(guide.instructions)
                **When to plan "current_weather" steps:**
                - When users ask for current weather conditions
                - For real-time weather information requests
                - When location-specific current conditions are needed
                ...
            
            Planning example usage::
            
                >>> example = guide.examples[0]
                >>> print(f"Scenario: {example.scenario_description}")
                Scenario: Getting current weather for a location
                >>> print(f"Expected output: {example.step.expected_output}")
                Expected output: CURRENT_WEATHER
            
            Integration with planning system::
            
                >>> # Orchestrator uses guidance during plan generation
                >>> if user_query_mentions_weather():
                ...     weather_guide = get_capability_guide("current_weather")
                ...     if matches_planning_criteria(query, weather_guide.instructions):
                ...         plan.add_step(weather_guide.examples[0].step)
        
        .. seealso::
           :class:`framework.base.OrchestratorGuide` : Guidance structure and interface
           :class:`framework.base.PlannedStep` : Step structure used in planning examples
           :meth:`_create_classifier_guide` : Classification guidance for capability selection
        """
        example = OrchestratorExample(
            step=PlannedStep(
                context_key="current_weather",
                capability="current_weather",
                task_objective="Get current weather conditions for the specified location",
                expected_output=registry.context_types.CURRENT_WEATHER,
                success_criteria="Current weather data retrieved with temperature and conditions",
                inputs=[]
            ),
            scenario_description="Getting current weather for a location",
            notes=f"Output stored as {registry.context_types.CURRENT_WEATHER} with live weather data."
        )
        
        return OrchestratorGuide(
            instructions=f"""**When to plan "current_weather" steps:**
- When users ask for current weather conditions
- For real-time weather information requests
- When location-specific current conditions are needed

**Output: {registry.context_types.CURRENT_WEATHER}**
- Contains: location, temperature, conditions, timestamp
- Available for immediate display or further analysis

**Location Support:**
- Supports: San Francisco, New York, Prague
- Defaults to San Francisco if location not specified""",
            examples=[example],
            order=5
        )
    
    def _create_classifier_guide(self) -> Optional[TaskClassifierGuide]:
        """Provide task classification guidance for intelligent capability selection.
        
        Creates comprehensive guidance for the framework's task classification system
        to understand when user queries require weather data retrieval capabilities.
        This guidance enables accurate capability selection through clear examples
        and reasoning patterns that distinguish weather-related tasks from other queries.
        
        The guide provides positive and negative examples with detailed reasoning
        to train the classification system's decision-making process, ensuring
        accurate capability activation while avoiding false positives that could
        lead to unnecessary weather service calls.
        
        Classification Criteria:
            The guide establishes clear patterns for weather capability activation:
            
            - **Positive Indicators**: Current weather requests, real-time conditions, location-specific queries
            - **Negative Indicators**: Historical weather, forecasts, non-weather information requests
            - **Edge Cases**: Ambiguous queries that require careful analysis
            - **Reasoning Patterns**: Logical frameworks for classification decisions
        
        Training Examples:
            The guide includes diverse query examples that help the classifier:
            
            1. **Recognize Patterns**: Learn common weather request formulations
            2. **Distinguish Context**: Differentiate current vs. historical weather
            3. **Handle Ambiguity**: Make reasonable decisions for unclear queries
            4. **Avoid False Positives**: Prevent activation for non-weather tasks
        
        Integration Benefits:
            Accurate classification enables:
            
            - **Efficient Execution**: Only activate weather capability when needed
            - **Resource Optimization**: Avoid unnecessary external service calls
            - **User Experience**: Faster responses through precise capability selection
            - **Error Reduction**: Minimize capability mismatches and execution failures
        
        :return: Complete task classifier guidance containing instructions, examples,
            and classification logic, or None if classification guidance is not needed
        :rtype: Optional[TaskClassifierGuide]
        
        .. note::
           Classification guidance is used during the task analysis phase before
           execution planning. It helps determine which capabilities should be
           considered for inclusion in the execution workflow.
        
        .. warning::
           Classification examples should be comprehensive and representative of
           real user queries. Incomplete or biased examples can lead to poor
           classification accuracy and suboptimal capability selection.
        
        Examples:
            Classifier guidance structure::
            
                >>> capability = CurrentWeatherCapability()
                >>> guide = capability._create_classifier_guide()
                >>> print(guide.instructions)
                Determine if the task requires current weather information for a specific location.
            
            Classification example analysis::
            
                >>> positive_example = guide.examples[0]
                >>> print(f"Query: {positive_example.query}")
                Query: What's the weather like in San Francisco right now?
                >>> print(f"Result: {positive_example.result}")
                Result: True
                >>> print(f"Reason: {positive_example.reason}")
                Reason: Request asks for current weather conditions in a specific location.
            
            Integration with classification system::
            
                >>> # Classifier uses guidance to analyze user queries
                >>> query = "How's the weather today?"
                >>> guide = get_classifier_guide("current_weather")
                >>> should_activate = classifier.analyze_query(
                ...     query, guide.instructions, guide.examples
                ... )
                >>> print(f"Activate weather capability: {should_activate}")
                Activate weather capability: True
        
        .. seealso::
           :class:`framework.base.TaskClassifierGuide` : Classification guidance structure
           :class:`framework.base.ClassifierExample` : Example structure for training
           :meth:`_create_orchestrator_guide` : Orchestration guidance for planning
        """
        return TaskClassifierGuide(
            instructions="Determine if the task requires current weather information for a specific location.",
            examples=[
                ClassifierExample(
                    query="What's the weather like in San Francisco right now?",
                    result=True,
                    reason="Request asks for current weather conditions in a specific location."
                ),
                ClassifierExample(
                    query="How's the weather today?",
                    result=True,
                    reason="Current weather request, though location may need to be inferred."
                ),
                ClassifierExample(
                    query="What was the weather like last week?",
                    result=False,
                    reason="Request is for historical weather data, not current conditions."
                ),
                ClassifierExample(
                    query="What tools do you have?",
                    result=False,
                    reason="Request is for tool information, not weather."
                ),
            ],
            actions_if_true=ClassifierActions()
        )